import 'package:cloud_firestore/cloud_firestore.dart'; // For Timestamp and DocumentSnapshot
import 'package:json_annotation/json_annotation.dart';
import 'package:mahakka/memo/base/memo_accountant.dart';
import 'package:mahakka/memo/base/memo_verifier.dart';
import 'package:mahakka/memo/firebase/topic_service.dart';
import 'package:mahakka/memo/model/memo_model_creator.dart';
import 'package:mahakka/memo/model/memo_model_topic.dart';
import 'package:mahakka/memo/model/memo_model_user.dart';

part 'memo_model_post.g.dart'; // This file will be generated by build_runner

// Helper functions for DateTime <-> Timestamp conversion for json_serializable
DateTime? _dateTimeFromJson(Timestamp? timestamp) => timestamp?.toDate();

Timestamp? _dateTimeToJson(DateTime? dateTime) => dateTime == null ? null : Timestamp.fromDate(dateTime);

@JsonSerializable(explicitToJson: true, includeIfNull: false) // includeIfNull: false is common
class MemoModelPost {
  @JsonKey(includeToJson: false, includeFromJson: false) // Firestore ID, set manually from DocumentSnapshot
  String id;

  String? text;
  String? imgurUrl;
  String? youtubeId;

  @JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
  DateTime? createdDateTime;

  int? popularityScore;
  int? likeCounter;
  int? replyCounter;

  String creatorId;
  String topicId;
  List<String> tagIds;

  // --- Transient (Client-Side) Fields ---
  //   @JsonKey(ignore: true) // Will not be included in JSON
  //   final String? age;
  @JsonKey(ignore: true)
  MemoModelCreator? creator;

  @JsonKey(ignore: true)
  MemoModelTopic? topic;

  @JsonKey(ignore: true)
  final String? created; // Original string form, if needed for display

  @JsonKey(ignore: true)
  String? _ageCache; // Renamed from _age to avoid conflict if 'age' field exists from Firestore

  @JsonKey(ignore: true) // Will not be included in JSON
  final List<String> urls = [];

  @JsonKey(ignore: true) // This is crucial for pagination
  DocumentSnapshot? docSnapshot;

  // --- Constructor ---
  MemoModelPost({
    required this.id,
    this.text,
    this.imgurUrl,
    this.youtubeId,
    this.createdDateTime,
    this.popularityScore,
    this.likeCounter,
    this.replyCounter,
    this.creatorId = '',
    this.topicId = '',
    this.tagIds = const [],
    this.creator, // Can be set after fetching post data
    this.topic, // Can be set after fetching post data
    this.created, // Original string, passed if available
    this.docSnapshot, // For pagination
  }) {
    // If createdDateTime is null but 'created' string exists, try to parse it
    if (this.createdDateTime == null && this.created != null && this.created!.isNotEmpty) {
      try {
        this.createdDateTime = DateTime.parse(this.created!);
      } catch (e) {
        print("Error parsing 'created' string to DateTime: $e");
        // Keep createdDateTime null if parsing fails
      }
    }
  }

  // --- Age Calculation (Lazy and Cached) ---
  @JsonKey(ignore: true) // The getter itself is not part of JSON
  String get age {
    // Your original 'age' property for display
    // if (_ageCache != null && _ageCache!.isNotEmpty) {
    //   return _ageCache!;
    // }
    //TODO no caching to have exact seconds and minutes
    _ageCache = _calculateAgeString();
    return _ageCache!;
  }

  String _calculateAgeString() {
    if (createdDateTime == null) return ""; // Or "Just now", "Unknown"
    final DateTime now = DateTime.now();
    final Duration difference = now.difference(createdDateTime!);

    if (difference.inSeconds < 60) return "${difference.inSeconds}s";
    if (difference.inMinutes < 60) return "${difference.inMinutes}m";
    if (difference.inHours < 24) return "${difference.inHours}h";
    if (difference.inDays < 7) return "${difference.inDays}d";
    if (difference.inDays < 30) return "${(difference.inDays / 7).floor()}w";
    if (difference.inDays < 365) return "${(difference.inDays / 30).floor()}mo";
    return "${(difference.inDays / 365).floor()}y";
  }

  // --- JSON Serialization ---
  factory MemoModelPost.fromJson(Map<String, dynamic> json) => _$MemoModelPostFromJson(json);

  Map<String, dynamic> toJson() => _$MemoModelPostToJson(this);

  // --- Factory to include DocumentSnapshot and ID ---
  // This is the method your PostService should use when creating instances from Firestore
  factory MemoModelPost.fromSnapshot(DocumentSnapshot snap) {
    if (!snap.exists || snap.data() == null) {
      // Handle non-existent or empty snapshot if necessary, or let it throw
      // For this example, we assume valid data or throw if data is not a map.
      print("Warning: Document ${snap.id} does not exist or has no data.");
      // You might want to return a specific state or throw a custom error.
      // For now, attempting to proceed might lead to errors in fromJson if data is truly null.
      // A safer approach:
      if (snap.data() == null) {
        throw Exception("Document ${snap.id} data is null");
      }
    }
    final data = snap.data() as Map<String, dynamic>;
    return MemoModelPost.fromJson(data)
      ..id = snap
          .id // Set the document ID
      ..docSnapshot = snap; // Store the snapshot for pagination
  }

  // --- Your existing methods ---
  static Future<MemoModelPost> createDummy(MemoModelCreator memoModelCreator) async {
    MemoModelTopic topic = MemoModelTopic.createDummy(); // Assuming this exists
    return MemoModelPost(
      id: "3228faaa15d9512ee6ecc29b8808876a7680e6d7493c22014b942825c975c0ca",
      created: "11.11.1911 11:11",
      createdDateTime: DateTime.now().subtract(const Duration(days: 5)),
      creator: memoModelCreator,
      creatorId: memoModelCreator.id,
      imgurUrl: "https://i.imgur.com/YbduTBp.png",
      likeCounter: 33,
      replyCounter: 2,
      text: "SAFDHSF DSF HDSFHDSKJ HFDSKJ HFDSJHF DHSFKJH DSJFHDSKJ HFKJDSH",
      popularityScore: 123456,
      topic: topic,
      topicId: topic.id,
      tagIds: ["dummyTag1", "dummyTag2"],
    );
  }

  Future<dynamic> publishReplyTopic(MemoModelUser user, String replyText) async {
    MemoVerificationResponse verifier = MemoVerifier(replyText).checkIsValidText();
    if (verifier == MemoVerificationResponse.valid) {
      return MemoAccountant(user).publishReplyTopic(this, replyText);
    } else {
      return verifier;
    }
  }

  Future<dynamic> publishReplyHashtags(MemoModelUser user, String text) async {
    MemoVerificationResponse verifier = MemoVerifier(text).checkIsValidText();
    if (verifier != MemoVerificationResponse.valid) return verifier;
    return MemoAccountant(user).publishReplyHashtags(this, text);
  }

  static Future<dynamic> publishImageOrVideo(MemoModelUser user, String text, String? topic) async {
    MemoVerificationResponse res = MemoVerifier(text).checkIsValidText();
    if (res != MemoVerificationResponse.valid) return res;
    return MemoAccountant(user).publishImgurOrYoutube(topic, text);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is MemoModelPost && runtimeType == other.runtimeType && id == other.id;
  }

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() {
    return 'MemoModelPost(id: $id, text: $text, creatorId: $creatorId)';
  }

  Future<void> loadTopic() async {
    // Changed return type to Future<void>
    if (topicId.isNotEmpty) {
      topic = await TopicService().getTopicOnce(topicId);
    }
  }
}

// // [1]
// import 'package:cloud_firestore_platform_interface/cloud_firestore_platform_interface.dart'; // For Timestamp
// import 'package:json_annotation/json_annotation.dart';
// // Your other imports
// import 'package:mahakka/memo/base/memo_accountant.dart';
// import 'package:mahakka/memo/base/memo_verifier.dart';
// import 'package:mahakka/memo/firebase/topic_service.dart';
// // Or if you directly use cloud_firestore package:
// // import 'package:cloud_firestore/cloud_firestore.dart';
//
// import 'package:mahakka/memo/model/memo_model_creator.dart';
// import 'package:mahakka/memo/model/memo_model_topic.dart';
// import 'package:mahakka/memo/model/memo_model_user.dart';
//
// part 'memo_model_post.g.dart'; // This file will be generated
//
// // Helper functions for DateTime <-> Timestamp conversion
// // These need to be top-level or static methods in a class for json_serializable
// DateTime? _dateTimeFromJson(Timestamp? timestamp) => timestamp?.toDate();
// Timestamp? _dateTimeToJson(DateTime? dateTime) => dateTime == null ? null : Timestamp.fromDate(dateTime);
//
// @JsonSerializable(explicitToJson: true)
// class MemoModelPost {
//   // PrimaryKey for Firestore document
//   // This 'id' should be set to the Firestore document ID when fetching.
//   // When creating a new post, Firestore can auto-generate this.
//   String id;
//
//   MemoModelPost({
//     required this.id, // ID is now required
//     this.text,
//     this.imgurUrl,
//     this.youtubeId,
//     this.creator, // Will not be serialized directly
//     this.popularityScore,
//     this.likeCounter,
//     this.replyCounter,
//     this.created,
//     this.age, // Will not be serialized
//     this.topic, // Will not be serialized directly
//     this.creatorId = '',
//     this.topicId = '',
//     required this.tagIds,
//     this.createdDateTime,
//   }) {
//     if (createdDateTime == null && created != null && created!.isNotEmpty) {
//       createdDateTime = DateTime.parse(created!);
//     }
//     // urls and hashtags are instance variables, initialized empty.
//     // They are not part of the constructor parameters if they are always empty initially
//     // and populated later.
//   }
//
//   // Fields to be serialized
//   final int? popularityScore;
//   String? text;
//   final String? imgurUrl;
//   String? youtubeId;
//
//   // Private member variable to cache the calculated age
//   @JsonKey(ignore: true) // Will not be included in JSON
//   String _age = "";
//
//   // / Getter for the 'age'
//   // This will calculate the age on first access and cache it.
//   String get ageCalc {
//     // If _age is already calculated and cached, return it
//     if (_age.isNotEmpty) {
//       return _age;
//     }
//     // If not cached, calculate, cache, and then return it
//     _age = _calculateAge();
//     return _age;
//   }
//
//   // Private method to perform the age calculation
//   String _calculateAge() {
//     if (createdDateTime == null) return "";
//
//     final DateTime now = DateTime.now();
//     final Duration difference = now.difference(createdDateTime!);
//
//     if (difference.inSeconds < 60) {
//       return "${difference.inSeconds}s ago";
//     } else if (difference.inMinutes < 60) {
//       return "${difference.inMinutes}m ago";
//     } else if (difference.inHours < 24) {
//       return "${difference.inHours}h ago";
//     } else if (difference.inDays < 7) {
//       return "${difference.inDays}d ago";
//     } else if (difference.inDays < 30) {
//       // For weeks, approximately
//       final weeks = (difference.inDays / 7).floor();
//       return "${weeks}w ago";
//     } else if (difference.inDays < 365) {
//       // For months, approximately
//       final months = (difference.inDays / 30).floor();
//       return "${months}mo ago";
//     } else {
//       // For years, approximately
//       final years = (difference.inDays / 365).floor();
//       return "${years}y ago";
//     }
//   }
//
//   @JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
//   DateTime? createdDateTime; // Serialized as Timestamp
//
//   final int? likeCounter;
//   final int? replyCounter;
//
//   @JsonKey(ignore: true) // Will not be included in JSON
//   final List<String> urls = [];
//
//   @JsonKey(ignore: true) // Will not be included in JSON (only creatorId is serialized)
//   MemoModelCreator? creator;
//
//   @JsonKey(ignore: true) // Will not be included in JSON (only topicId is serialized)
//   MemoModelTopic? topic;
//
//   @JsonKey(ignore: true) // Will not be included in JSON
//   final String? age;
//
//   @JsonKey(ignore: true) // Will not be included in JSON
//   final String? created;
//
//   // IDs for relationships - these will be serialized.
//   String creatorId;
//   String topicId;
//   List<String> tagIds = [];
//
//   /// Factory constructor for creating a new MemoModelPost instance from a map.
//   factory MemoModelPost.fromJson(Map<String, dynamic> json) => _$MemoModelPostFromJson(json);
//
//   /// Converts this MemoModelPost instance into a map.
//   Map<String, dynamic> toJson() => _$MemoModelPostToJson(this);
//
//   // --- Static lists and methods (Not part of JSON serialization) ---
//   // static final List<MemoModelPost> allPosts = [];
//   // static final List<MemoModelPost> ytPosts = [];
//   // static final List<MemoModelPost> imgurPosts = [];
//   // static final List<MemoModelPost> hashTagPosts = [];
//   // static final List<MemoModelPost> topicPosts = [];
//
//   static Future<MemoModelPost> createDummy(MemoModelCreator memoModelCreator) async {
//     MemoModelTopic topic = MemoModelTopic.createDummy();
//
//     MemoModelPost memoModelPost = MemoModelPost(
//       id: "3228faaa15d9512ee6ecc29b8808876a7680e6d7493c22014b942825c975c0ca",
//       age: "11d", // Not serialized, kept for original logic if any
//       created: "11.11.1911 11:11", // Not serialized
//       createdDateTime: DateTime.now().subtract(const Duration(days: 5)), // Example DateTime
//       creator: memoModelCreator, // Not serialized
//       creatorId: memoModelCreator.id, // Serialized
//       imgurUrl: "https://i.imgur.com/YbduTBp.png",
//       likeCounter: 33,
//       replyCounter: 2,
//       text: "SAFDHSF DSF HDSFHDSKJ HFDSKJ HFDSJHF DHSFKJH DSJFHDSKJ HFKJDSH",
//       popularityScore: 123456,
//       topic: topic, // Not serialized
//       topicId: topic.id, // Serialized
//       tagIds: ["dummyTag1", "dummyTag2"],
//     );
//     // Manually populate urls/hashtags if needed for the dummy AFTER construction
//     // for runtime use, as they won't be part of JSON.
//     // memoModelPost.urls.add("http://example.com");
//     // memoModelpost.tagIds.add("#dummy");
//     return memoModelPost;
//   }
//
//   // static void addToGlobalPostList(List<MemoModelPost> p) {
//   //   MemoModelPost.allPosts.addAll(p);
//   //   for (var element in p) {
//   //     if (element.imgurUrl != null && element.imgurUrl!.isNotEmpty) {
//   //       imgurPosts.add(element);
//   //     } else if (element.youtubeId != null && element.youtubeId!.isNotEmpty) {
//   //       ytPosts.add(element);
//   //     } else if (element.hashtags.isNotEmpty) {
//   //       hashTagPosts.add(element);
//   //     } else if (element.topic != null) {
//   //       topicPosts.add(element);
//   //     }
//   //   }
//   // }
//
//   // --- Publish methods (Remain the same) ---
//   Future<dynamic> publishReplyTopic(String replyText) async {
//     MemoVerificationResponse verifier = MemoVerifier(replyText).checkIsValidText();
//     if (verifier == MemoVerificationResponse.valid) {
//       var user = await MemoModelUser.getUser();
//       return MemoAccountant(user).publishReplyTopic(this, replyText);
//     } else {
//       return verifier;
//     }
//   }
//
//   Future<dynamic> publishReplyHashtags(String text) async {
//     MemoVerificationResponse verifier = MemoVerifier(text).checkIsValidText();
//     if (verifier != MemoVerificationResponse.valid) return verifier;
//     var user = await MemoModelUser.getUser();
//     return MemoAccountant(user).publishReplyHashtags(this, text);
//   }
//
//   static Future<dynamic> publishImageOrVideo(String text, String? topic) async {
//     MemoVerificationResponse res = MemoVerifier(text).checkIsValidText();
//     if (res != MemoVerificationResponse.valid) return res;
//     var user = await MemoModelUser.getUser();
//     return MemoAccountant(user).publishImgurOrYoutube(topic, text);
//   }
//
//   // --- Equals and HashCode ---
//   // Now using 'id' (Firestore Document ID) as the primary basis for equality.
//   @override
//   bool operator ==(Object other) {
//     if (identical(this, other)) return true;
//     return other is MemoModelPost && runtimeType == other.runtimeType && id == other.id; // Primary check using the document ID
//   }
//
//   @override
//   int get hashCode => id.hashCode; // Base on document ID
//
//   @override
//   String toString() {
//     return 'MemoModelPost(id: $id, text: $text, creatorId: $creatorId)';
//   }
//
//   void loadTopic() async {
//     topic = await TopicService().getTopicOnce(topicId);
//   }
// }
